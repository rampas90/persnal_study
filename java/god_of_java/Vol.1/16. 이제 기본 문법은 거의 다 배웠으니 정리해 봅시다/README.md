## 16. 이제 기본 문법은 거의 다 배웠으니 정리해 봅시다

### 1. 객체지향 개발과 관련된 용어들

1. 클래스~class~
2. 상태~state~와 행위~behavior~
3. 캡슐화~Encapsulation~
4. 메시지
5. 객체~Object~
6. 상속~Inheritance~
7. 다형성~Polymorphism~
8. Overriding
9. Overloading

##### 1) 클래스(Class)
> `상태` 와 `행위`를 갖는 자바의 기본 단위를 의미한다.

##### 2) 상태(state)와 행위(behavior)
> `상태`는 클래스나 인스턴스 변수로, `행위`는 메소드로 표현할 수 있다.

##### 3) 캡슐화(Encapsulation)
> 연관된 `상태`와`행위`를 결정하는 기능을 묶어 주는 것을 의미한다.
> 이렇게 묶어주면 기능을 클래스 밖에서 접근 가능한 대상을 제한하는 `정보은닉`이 가능하다
> 그리고, 하나의 객체를 위한 코드가, 다른 객체를 위한 코드와 무관하게 수행할 수 있는 `모듈화`가 가능해진다.
> 이처럼 묶여 있는 가장 작은 단위를 클래스라고 보면 된다.

```java
public class Common{
	private int state;	//private로 선언함으로써 정보 은닉
    public void setState(int newState){
    	// 상태를 변경 가능
    }
}
```

##### 4) 메시지
> 메소드에서 다른 메소드를 호출할 때 전달하는 값을 메시지라고 한다.
> 자바에서는 메소드를 호출할 때 넘겨주는 매개 변수들이 여기에 속한다.


##### 5) 객체(Object)
> 클래스는 사물의 단위를 의미하지만, 객체는 각 사물을 의미한다. 예를 들면 "책"은 클래스
> <자바의신>은 책 중의 하나를 의미하는 객체라고 볼 수 있다.
> `Book javaSolutions=new Book();`

##### 6) 상속
> 부모에 선언된 변수와 메소드에 대한 사용권을 갖는 것을 말한다. 
> 즉, 클래스 선언시 extends를 사용하여 확장하거나, implements를 사용하여 구현한 경우가 여기에 속한다.


##### 7) 다형성
> 이 세상에 부모와 자식이 똑같을 수가 없고, 자식들도 같을 수가 없다.
> 마찬가지로 자바에서는 부모 클래스에서 파생된 자식 클래스들의 기능이 각기 다를 수 있다는 것을 의미한다.

##### 8) Overriding
> 부모 클래스에 선언되어 있는 메소드와 동일한 선언을 갖지만 구현이 다른것을 의미한다.
> 자바에서 다형성을 제공하는 하나의 방법이 바로 Overriding 이다.

##### 9) Overloading
> 메소드의 이름은 동일해도, 매개 변수들을 다르게 하는 것을 의미한다.
> 그래서, 동일한 기능은 하지만, 메소드에 넘겨줄 수 있는 매개 변수의 타입을 다양하게 함으로써 메소드를 사용하는 다른 개발자가 쉽게 구현할 수 있게 해준다.


---

### 2. 패키지와 import

패키지는 클래스들을 그룹화하기 위한 단위이다. 만약 이러하나 패키지가 없다면, 자바의 소스코드들은 뒤죽 박죽되어 매우 복잡해질 것이다. 다른 패키지에 선언되어 있는 클래스를 사용하기 위해서는 클래스 선언 앞에 import 문장들이 있어야 한다

	패키지 선언시 유의사항들
- 패키지는 `package`로 시작하며 패키지로 내려갈 때마다 `.`을 찍어 주어야 한다.
- 반드시 소스의 가장 첫 줄에 존재해야 한다
- 패키지 이름에 자바 예약어가 포함되면 안된다.
- 모두 소분자로 구성하는 것이 일반적이다
- 일반적인 패키지는 `java`나 `javax`로 시작하면 안된다.
- 패키지에 해당하는 폴더에 클래스가 존재하는 것이 일반적이다.


	`import`는
- 다른 패키지에 있는 클래스를 사용하기 위한 문장이다.
- 다른 클래스에 `static`으로 선언되어 있는 접근 가능한 변수를 참조하려면 `import static`을 사용한다.
- 하나의 패키지 내에 있는 모든 클래스를 참조하려면 `*`를 사용



---


### 3. 자바에서 사용되는 타입의 종류

자바의 타입은 크게 기본 자료형과 참조 자료형으로 나뉜다.

	8개의 기본 자료형
숫자와 불린값을 나타내기 위한 자료형으로 마음대로 추가로 만들 수 없다.
- 정수형 : byte, short, int, long, char
- 소수형 : float, double
- 기타 : boolean



> 정수형 값의 범위는 다음과 같다.

| 타입   | 최소 | 최대 | 비트수 |
|-------|---------|---------|----|
| byte  | -2^7^   | 2^7^-1  | 8  |
| short | -2^15^  | 2^15^-1 | 16 |
| int   | -2^31^  | 2^31^-1 | 32 |
| long  | -2^63^  | 2^36^-1 | 64 |
| char  |    0    | 2^16^-1 | 16 |

> 기본 자료형의 기본값은 다음과 같다.

- byte : 0
- short : 0
- int : 0
- long : 0L
- float : 0.0f
- double : 0.0d
- char : '\u0000'
- boolean : false


	참조 자료형
기본 자료형을 제외한 모든 타입을 말한다.
모든 클래스는 참조 자료형이라고 생각하면 된다.

> 참조 자료형과 기본 자료형의 차이

- 초기화할 때 : 기본 자료형은 값을 바로 지정하면 되지만, 참조 자료형은 일반적으로 `new`와 `생성자`를 지정하여 객체를 생성한다.
- 메소드를 호출할 때의 매개 변수 : 기본 자료형 및 참조 자료형 모두 값을 전달하지만, 참조 자료형 안에 있는 변수들은 참조 주소를 전달한다.

> 특수한 참조 자료형

- String : String 클래스는 `new`를 이용하여 객체를 생성할 필요가 없는 특수한 클래스다. 그리고, + 연산까지 가능한 유일한 클래스다

---


### 4. 변수의 종류

	자바 변수의 종류
1. `지역변수(local variables)` : 지역 변수를 선언한 곳에서부터 생명이 시작되고, 지역변수를 선언한 중괄호가 끝나면 소멸

2. `매개 변수(parameters)` : 메소드가 호출될 때 생명이 시작되고, 메소드가 끝나면 소멸(정확히 호출될 때 시작하지는 않지만, 이렇게 기억해두어도 무방)

3. `인스턴스 변수(instance variables)` : 객체가 생성될 때 생명이 시작되고, 그 객체를 참조하고 있는 다른 객체가 없으면 소멸

4. `클래스 변수(class variables)` : 클래스가 생성될 때 생명이 시작되고, 자바 프로그램이 끝날 때 소멸

```java
public class VariableTypes{
	int instanceVariable;
    static int classVariable;
    public void method(int parameter){
    	int localVariable;
    }
}
```

---

### 5. 계산을 쉽게 도와주는 연산자들

	연산자의 종류
- 할당 연산자 : `=`
- 사칙 연산자 : `+`, `-`, `*`, `/`, `%`
- 대입 연산자 : `+=`, `-=`, `*=`, `/=`, `%=`
- 단항 연산자 : `++`, `--`
- 비교 연산자 : `==`, `!=`, `>`, `<`, `>=`, `<=`
- 조건적 논리 연산자 : `&&`, `||`
- 논리 연산자 : `!`, `&`, `|`, `^`
- 삼항 연산자 : `? :`
- Bitwise 연산자 : `&(AND)`, `|(OR)`, `^(XOR)`, `~(NOT)`
- Bit 이동 연산자 : `<<`, `>>`, `>>>`
- Bit 대입 연산자 : `&=`, `|=`, `^=`, `<<=`, `>>=`, `>>>=`

> 자세한 연산자 연산순위는 p.461 참조


---


### 6. 아무나 사용 못하게 막아주는 접근 제어자

자바는 4가지 접근 제어자를 제공한다. 이 접근 제어자는 클래스, 변수, 메소드 등을 선언할 때 사용하고, 선언한 해당 항목의 범위를 제한하는 것이 그 목적이다

- public : 누구나 접근 가능하다
- protected : 같은 패키지 내에 있거나 상속받은 경우에만 접근가능하다.
- package-private : 접근제어자 적지 않을 경우이며, 같은 패키지 내에 있을때만 접근가능하다
- private : 해당 클래스 내에서만 접근 가능하다.

|  | 해당 클래스 안에서 | 같은 패키지에서 | 상속받은 클래스에서 | import한 클래스에서 
|--------|--------|--------|--------
| public | O | O | O | O
| protected | O | O | O | X
| package private | O | O | X | X
| private | O | X | X | X


---

### 7. 선언할 때 사용할 수 있는 각종 제어자들

> 클래스, 메소드, 변수를 선언할 때 사용할 수 있는 제어자는 접근 제어자만 있는 것이 아니다. 어떤 제어자들이 어디에서 사용할 수 있는지는 다음 표를 참고

| 제어자 | 클래스  | 메소드 | 변수 |
|--------|--------|--------|
| 접근제어자 : `public`,`protected`,`private` | O | O | O |
| 구현필요제어자 : `abstract` | O | O | X |
| 하나의 인스턴스만 허용하는 제어자 : `static` | O | O | O |
| 값수정 제한제어자 : `final` | O | O | O |
| strict 소수값제어자 : `strictfp` | O | O | X |
| 어노테이션 | O | O | O |
| 동시접근 제어자 : `synchronized` | X | O | X |
| 다른언어로 구현된것을 명시하는 제어자 : `native` | X | O | X |
| 실행시의 동작 방법을 알리는 제어자 : `transient`, `volatile` | X | O | O |

---


### 8. 자바를 구성하는 클래스, 인터페이스, abstract 클래스

자바에서 만든 코드를 관리하는 클래스 파일(.class)이 되는 타입의 종류

- 클래스
- 인터페이스
- abstract 클래스
- enum 클래스
- 어노테이션 선언 클래스

> `인터페이스`와 `abstract클래스`, `클래스`의 차이

1) 인터페이스
- 어떤 메소드가 존재해야 하는지에 대한 선언만 되어 있다.
- 절대로 구현되어 있는 메소드가 있어서는 안된다.
- 인터페이스를 구현하는 클래스에서는 `implements`를 사용하여 선언한다

2) ==abstract== 클래스
- 구현되어 있는 메소드가 있어도 상관없다.
- `abstract`로 선언된 메소드가 1개 이상일 경우에는 반드시 abstract 클래스로 선언해야 한다.
- `abstract`으로 선언된 메소드는 절대로 구현되어 있어서는 안된다.
- `인터페이스`나 `abstract` 클래스와는 다르게 모든 메소드가 구현되어 있어야 한다.

3) 클래스
- `인터페이스`나 `abstract` 클래스와는 다르게 모든 메소드가 구현되어 있어야 한다.

> 클래스 선언 예

```java
public class Sample extends SuperClass implements InterfaceA, InterfaceB{
	//내용생략
}
```

> Sample이라는 이름을 가지는 클래스 선언

- 파일 이름은 `Sample.java`
- 대문자로 시작하고, 추가 단어가 있을 경우에는 첫 문자만 대문자를 사용

> SuperClass라는 클래스를 확장

- `extends` 뒤에 부모 클래스의 이름을 명시하며, 반드시  하나의 클래스만 지정 가능
- `abstract` 클래스도 `extends`로 확장할 수 있다.

> InterfaceA 와 InterfaceB를 구현함

- 한개 이상의 구현할 인터페이스 이름을 명시한다.
- `implements`로 구현을 한다고 명시할 때에는 인터페이스에 선언된 모든 메소드가 이 클래스에서 구현되어야 한다.

> 인터페이스 선언 예

```java
public interface InterfaceA{
	public void methodA();
    public void methodB();
}
```
- 구현되어 있는 메소드가 하나라도 있으면 안된다

> abstract 클래스 선언 예

```java
public abstract class AbstractClass{
	public abstract void methodC();
    public void methodD(){
    
    }
}
```
- abstract로 선언된 메소드가 하나라도 있을 경우 클래스는 abstract로 선언되어야만 한다

> enum 클래스 선언 예

```java
pubblic enum EnumClass{
	THREE_HOUR(18000),
    FIVE_HOUR(30000),
    /* 중간 생략 */
}
```
- enum 클래스는 상수를 열거하기 위한 용도로 사용한다.
- enum 클래스의 상수는 이름만 정의해도 된다.
- 별도의 생성자를 만들어 각 상수의 값을 지정할 수 있다.
- 모든 enum 클래스의 부모 클래스는 java.lang.Enum클래스 뿐이다.
- enum에 메소드를 만들어 기능 추가 가능

> 어노테이션 선언 예

```java
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AnnotationDefinition{
	public int number();
    public String text() default "This is first annotation";
}
```
- 대상(@Target)과 적용범위(@Retention)를 명시하는 것이 좋다
- `@interface`를 상요하여 어노테이션이라는 것을 명시한다

`참고로 interface나 abstract 클래스 모두 클래스 변수나 인스턴스변수를 선언할 수 있으며, 구현 및 확장하는 클래스에서는 이 값들을 사용할 수 있다.`

---

### 9. 메소드의 선언

> 기본적인 메소드의 선언 예

```java
public void method(String param, int... params){

}
```
- `method`라는 이름을 갖는 메소드다
- `public` 과 같은 제어자 선언이 가능하다
- `void`로 선언되어 있어 리턴되는 값이 없다.
- `param`이라는 `String`타입의 매개 변수를 가진다.
- `params`라는 여러개의 `int` 타입을 콤마로 구분하여 매개 변수로 지정 가능하다.

---

### 10. 자주 사용하게 되는 상속

자바 개발시에는 상속을 자주 사용하게 된다. 만약, 자주 사용하지 않고 상속되어 있는 클래스가 적다면, 리팩토링이라는 단계를 거쳐서 반복되는 메소드를 상위 클래스로 구분해 주는 것이 좋다. 그래야 코드의 재사용성과 유지보수성, 가독성이 높아진다.
상속 관계가 발생했을 때 생성자, 메소드, 변수는 각각 어떻게 지정하고 동작하게 되는지 정리해보자

1) 생성자
- 자식 클래스의 생성자가 호출되면 자동으로 부모 클래스의 매개 변수가 없는 기본생성자가 호출됨. 명시적으로 `super()`라고 지정 가능하다
- 부모 클래스의 생성자를 명시적으로 호출하려면 `super()`를 사용하면 된다.

2) 메소드
- 부모 클래스에 선언된 메소드들이 자신의 클래스에 선언된 것처럼 사용 가능하다(private 제외)
- 부모 클래스에 선언된 메소드와 동일한 시그네쳐를 사용함으로써 메소드 `overriding`이 가능하다
- 부모 클래스에 선언되어 있지 않은 이름의 새로운 메소드 선언이 가능하다.

3) 변수
- 부모 클래스에 private로 선언된 변수를 제외한 모든 변수가 자신의 클래스에 선언된 것처럼 사용 가능
- 부모 클래스에 선언된 변수와 동일한 이름을 가지는 변수 선언 가능(권장하지 않음)
- 부모 클래스에 선언되어 있지 않는 이름의 변수 선언 가능

---


### 11.예외를 처리하자

> try-catch 기본구문

```java
try{
	//예외가 발생 가능한 문자
} catch(예외1 e1){
	// 예외1이 발생했을 때 처리문장
} catch(예외2 e2){
	// 예외2가 발생했을 때 처리문장
} finally{
	// try나 catch가 어떻게 수행되었든 간에 수행되는 문장
}
```

> 자바에서 사용하는 예외의 종류

- checked exception : try-catch로 묶어줘야 하는 예외이며, 컴파일시 예외처리여부를 체크한다.
- error : 자바 프로세스에 영향을 주는 예외이며, 실행시 발생한다.
- runtime exception 혹은 unchecked exception : try-catch로 묶지 않아도 컴파일시 체크를 하지 않는 예외이며, 실행시 발생하는 예외이다.

> throw 와 throws

- `thorw` : 예외 객체를 던지기 위해서 사용한다.
- `throws` : 예외가 발생하면 던질 것이라고 메소드 선언시 사용한다.
- 메소드를 선언할 때 매개 변수 소괄호 뒤에 `throws`라는 예약어를 적어 준 뒤 예외를 선언하면, 해당 메소드에서 선언한 예외가 발생할 때 호출한 메소드로 예외가 전달된다.
- 두 가지 이상의 예외를 던지게 된다면 `implements`처럼 콤마로 구분하여 예외 클래스 이름을 적어준다
- `try` 블록 내에서 예외를 발생시킬 경우에는 throw 라는 예약어를 적어 준 뒤 예외 객체를 생성하거나, 생성되어 있는 객체를 명시한다.
- `throw`한 예외 클래스가 catch 블록에 선언되어 있지 않거나, `throws` 선언에 포함되어 있지 않으면 컴파일 에러가 발생한다.
- `catch` 블록에서 예외를 `throw`할 경우에는 메소드 선언의 `throws` 구문에 해당 예외가 정의되어 있어야 한다.

--- 




## 총정리 요약 문제



1) 참조 자료형(Reference type)과 기본 자료형(Primitive type)의 차이를 정리해 주세요.
기본 자료형은 이미 정해져 있는 값으로 정수형 소수형 불린 등이 이에 속한다 또한 마음대로 추가하거나 변경할수 없다. 

참조 자료형은 기본형을 제외한 나머지로 주로 클래스가 이에 속하며 
일반적으로 new 라는 예약어를 통해 생성한다 .
이때 string은 new없이도 생성가능한 특이한 케이스이다


2) 기본 자료형 8 가지를 나열하고 각 타입의 특징을 정리해 주세요.
byte
8비트가 모여 1바이트가 된다.

int
정수형으로 데이터 타입으로 일반적으로 가장 많이 사용한다.

short
그다음

long
정수형중 가장 큰 범위를 가진다

float
소수형이다.

double
소수형으로 일반적으로 가장 많이 사용한다

char
단일 문자열 타입이다.

boolean
true, false 갑을 가지며 기본값은 false이다


3) 형 변환이란 무엇이고 왜 해야 하나요?
넓은 범위로의 변환은 상관없지만 작은 범위로(축소)변환시에는 캐스팅을 명시적으로 해줘야 한다


4) if 문의 용도는 무엇이며, if-else와 if-else if 는 어떤 점이 다른지 정리해 주세요.
조건문으로 만약 ~~ 라면 else는 if의 조건문에 해당되지 않될경우 넘어가며 순차적으로 체크한다

5) switch-case 문의 용도를 정리해 주세요.
각 조건별로 로직을 수행하게 되며 break 문을 통해 각 케이스별로 설정을 해줘야 한다.


6) for, do-while, while 를 어떻게 사용하는지 1부터 10까지 더하는 코드를 예를 들어 정리해 주세요.
```java
int amount =0;	
for( int i=1; i<=10; i++ ){
	amount +=i;
}
System.out.println(amount);

int k=0;
int amount3=0;
while(k<11){
	amount3 += k;
	k++;
}
System.out.println("while = "+amount3);
```


7) 학생이라면 지금까지의 자신의 학점이나 등수를, 회사원이라면 지금까지의 고과를 String 배열에 넣고 출력하는 코드를 작성해 주세요.
```java
public void printScore(String score){
	System.out.println("Score = "+score);
}
```

8) 생성자는 무엇을 하는데 사용하는 것이며, 별도로 만들지 않아도 자동으로 생성되는 생성자에 대해서 정리해 주세요.
변수를 초기화 하는데 사용되며, 매개변수를 받는 생성자를 별도로 생성하지 않을 경우 기본생성자가 자동으로 생성된다.


9) Overloading은 무엇인가요? public void setData(int a) 라는 메소드를 원하시는 대로 Overloading 해 주세요.
```java
public void setData(int a String str){

}
```

10) 패키지를 선언하는 위치와 이름을 지정할 때의 유의점을 정리해 주세요.
페이지의 최상단에 위치하며 패키지 안으로 들어갈수록 `.`로 연결한다. 또한 이름에 자바 예약어를 사용하면 안되며 보통 소문자로 표기한다.


11) 다른 패키지에 선언된 클래스를 사용하기 위한 import 는 어디 위치에 선언해야하며, static import 은 무엇인지 정리해 주세요.

클래스 상단에 위치하며 패키지 하단에 입력한다. 
static import 는 static으로 정의된 메소드에 접근할때 사용된다.


12) 클래스란 무엇인가요? 다음의 단어들이 포함되는 문장을 작성하고, 주어진 단어의 의미도 같이 정리해 주세요.(속성, 상태)
자바의 가장 작은 단위로 속성은 인스턴스 변수나 클래스 변수들을 의미하며 상태혹은 속성이라고 정의하며
상태는 행동을 구현하는 메소드들이다.
클래스들은 이러한 것들을 묶어논 것이다.


13) 인터페이스, abstract 클래스, 클래스, Enum 클래스가 있는데 각각의 특징 및 다른 점을 정리해 주세요.
인터페이스는 "이러이러하게" 구현될 것이라고 선언만 해놓고 구현해놓지 않은 것, 
abstract 클래스는 일부 구현되어있는 클래스로 구현하려는 클래스를 extends로 상속하여 구현한다.
enum클래스는 상수를 정의한 클래스들


14) instanceof 라는 연산자의 용도를 정리해 주세요.
배열의 타입이 부모인지 자식인지 확인할때 사용한다.

15) 어떤 클래스를 상속받아 확장을 하면, 부모 클래스의 어떤 것들을 사용할 수 있는지 정리해 주세요.
변수, 메소드에 접근 가능

16) 변수를 final 로 선언하는 것이 어떤 의미가 있는지 정리해 주세요.
값의 변경이 안된다

17) 클래스를 final 로 선언하는 것이 어떤 의미가 있는지 정리해 주세요.
상속을 줄수 없다.

18) 변수를 static 으로 선언하는 것이 어떤 의미가 있는지 정리해 주세요.
클래스 변수로static 메소드에서 접근가능하다

19) 메소드를 static 으로 선언하는 것이 어떤 의미가 있는지 정리해 주세요.
객체를 생성하지 않아도 사용가능하며 단 클래스 변수만 사용가능하다.(인스턴스 변수는 사용 불가능)

20) try-catch-finally 블록은 왜 사용하고 각각의 블록이 어떤용도로 사용되는지 정리해 주세요.
예외처리를 할때 사용되며 try는 예외가 발생할 코드 catch 예외에 해당할때 실행될 코드 finally는 예외에 상관업이 무조건 출력될 부분











