
## 1. 데스크톱 애플리케이션

> 데스크톱 애플리케이션의 문제점

데스크톱 애플리케이션은 PC에 설치되어 실행하기 때문에 웹 애플리케이션보다는 실행 속도가 빠르다.
하지만, 다음 문제 때문에 기업용 애플리케이션의 아키텍쳐로 쓰기에 적합하지 않다.

1) 배포가 번거롭다
> 기능을 추가하거나 변경할 때마다 다시 배포해야하므로 매우 번거롭다.
> 백 대 이상의 PC에 배포애햐 한다고 생각해보자..
> 또한 출장 중을 예로들면 다른 PC에는 프로그램을 설치해야 하는데 이는 보안에도 좋지 않다.


2) 보안에 취약하다.
> 데이터베이스에 접속이 필요한 애플리케이션은 보안에 특이 취약하다. (접속정보가 고스란히 들어가있기때문에)

3) 해결방안
> 배포가 번거로운 문제는 자동갱신을 통하여 해결할 수 있다.
> 즉 애플리케이션을 실행할 때 먼저 서버에 갱신된 버전이 있는지 조회하는 방식이다
> 하지만 보안이 취약문제는 여전히 그대로이다 그 문제를 알아보자


클라이언트 - 서버애플리케이션의 특징
- 업무 변화에 대응하기 쉽다
- 서버쪽에서 데이터베이스와 접속 -> 보안이 강화된다.

p.27 ~ 34 예제 참조

클라인트 - 서버 구조의 장점
> 예제의 핵심은 서버에서 계산을 수행하고 그 결과를 클라이언트로 보내주는 것이다.
> 따라서 신규 연산자가 추가되더라도 서버쪽만 변경하면 됩니다. 클라이언트는 바뀌지 않기 때문에 다시 설치할 필요가 없는 개념이다.
> 이와 같이 데스크톱 애플리케이션의 기능 일부를 서버에 이관하는 구조로 만들면 **기능 변경이나 추가에 대해 보다 유연하게 대처**할 수 있다.

위 예제인 CalculatorServer의 문제는 한 번에 하나의 클라이언트 하고만 연결된다는 점이다.
자동적으로 현재 연결된 클라이언트와의 연결이 끊어질 때까지 다른 클라이언트는 기다려야만 한다

> 이런 문제들을 해결하기 위해 대부분의 서버프로그램은 멀티 프로세스 또는 멀티 스레드와 같은 병행처리 방식을 도입했다.


#### 멀티프로세스와 멀티쓰레드

1) 멀티 프로세스 방식 
- 클라이언트가 연결 요청을 하면 서버 프로그램은 자신을 복제하여 클라이언트에 대응하게 하고, 자신은 다른클라이언트의 요청을 기다린다.
- 이 방식은 원본 프로세스의 메모리를 모두 복제하기 때문에 자원낭비가 심하다.

2) 멀티 쓰레드 방식
- 클라이언트 요청을 처리하는 일부 코드만 별도로 분리하여 실행하기 때문에 전체메모리를 복제할 필요가 없어, 멀티 프로세스 방식보다 메모리 낭비가 적다

#### 다중 클라이언트의 요청처리

다중 클라이언트요청의 특징
- 클라이언트의 요청 처리 부분을 별도의 작업으로 분리한다.
- 분리된 작업은 스레드에 정의한다.
- 다중 클라이언트의 요청이 동시에 병행 처리된다.


#### 클라이언트 - 서버 아키텍처의 진화

> 전통적인 클라이언트 서버 아키텍쳐

서버는 데이터 처리를 맡고 클라이언트는 UI와 비즈니스 처리를 담당한다.
즉, 데스크톱 애플리케이션의 데이터 처리 부분을 공통화하여 서버로 이관한 것이다
이렇게 여러 PC에 분산되어 있는 자료를 하나의 서버에서 관리하면 자료의 중복이나 자료가 일치하지 않는 문제를 해소할 수 있다.

######단점

이 방식의 문제는 프로그램이 변경되면 PC에 다시 설치해야 한다는 것이었다. 
이전의 메인프레임 방식에서는 프로그램이 서버에 있어서 서버쪽만 변경하면 됬지만 C/S 방식에서는 그럴수가 없다.
전통적인 C/S 환경에서는 클라이언트가 DBMS로 바로 접속하기 때문에 보안 문제가 발생할 수 있다.
DBMS에 접속하려면 사용자 정보가 필요한데 이부분들이 보통 프로그램 코드에 들어있기때문이다.

> 개선된 클라이언트 - 서버 아키텍쳐

이런 문제들을 개선하기 위해 클라이언트의 업무 처리 부분은 서버로 이관하고, 클라이언트는 오로지 사용자와의 상화작용을 처리하는 UI만을 담당하게 된다.
즉 클라이언트는 데이터를 입력받을 화면을 사용자에게 제공하고, 입력받은 데이터가 형식에 맞는지 검사하고,  필요하다면 서버가 원하는 형식으로 변환하여 서버에 보낸다.
서버로부터 결과를 받으면 사용자가 이해하기 쉽게 화면을 꾸며 출력한다.
업무 처리 부분은 서버에게 위임하는 것이다

> 애플리케이션 서버

이렇게 업무 처리를 전담하는 서버를 '애플리케이션 서버'라고 부른다.
애플리케이션 서버는 클라이언트로부터 요청을 받으면 업무 로직에 따라 DBMS 서버를 사용하여 데이터를 처리한다.
또한, 클라이언트의 접근을 제어하여 무효한 접근을 차단하고, 함께 처리해야 할 작업들이 있다면 하나의 트랜잭션으로 묶어서 관리합니다.

>  특징

이방식은 클라이언트가 DB에 직접 접속하지 않기 때문에 DB 접속정보가 노출되는 사고를 막을 수 있다.
또한, 업무 처리 부분을 서버로 이전했기 때문에 서버에서 기능 변경을 하더라도 바로 클라이언트에 적용할 수 있다
물론 서버 쪽 변경만으로 배포 문제를 완전히 해결할 수 는 없지만 어느정도 잦은 배포를 줄일 수 있다.


> 웹애플리케이션 서버구조
- 클라이언트와의 통신은 웹 서버가 전담 -> 네트워크 및 멀티 스레드 프로그래밍으로부터 탈출
- 애플리케이션 서버는 애플리케이션 실행 및 관리에 집중


> 웹 어플리케이션 방식이 기존의 C/S 환경과 비교해서 무엇이 다른지 살펴보자

	배치
기존의 C/S환경은 비즈니스 처리 부분을 서버에 배치하고 UI 처리 부분을 클라이언트에 배치했다
업무가 변경되면 그에 따라 UI도 바뀌어야 하기 때문에 기능이 추가되거나 변경될 때마다 클라이언트 프로그램을 다시 설치해야 하는 문제가 있었다.

웹 환경에서는 비즈니스 로직과 UI로직을 모두 서버에 배치하기 때문에 기능이 추가되거나 변경되더라도 서버쪽만 바꾸면 된다. 따라서 배치하는 즉시 사용자는 재설치 없이 추가된 기능이나 변경된 기능을 이용할 수 있게 되는것이다.

다만, 웹 환경에서는 어플리케이션을 실행할 때마다 UI로직을 내려받아야 하기 때문에 네트워크 오버헤드(특정 기능을 수행하기 위해 추가로 사용되는 자원)가 발생한다.

	실행
웹 환경에서 어플리케이션 실행은 웹 브라우져를 통하여 이루어진다. 
웹브라우저가 설치되어 있고 인터넷에 연결되어 있다면 어디에서라도 애플리케이션을 실행할 수 있다.


	개발
C/S 환경에서는 데이터 통신을 위해 네트워크 프로그래밍을 해야 한다. 
또한, 서버에서는 다중 클라이언트의 요청을 동시에 처리하기 위해 멀티 스레드 프로그래밍을 해야 한다.

그러나 웹 환경에서는 웹 브라우저와 웹 서버가 그부분을 대신 처리해주고, 개발자는 단지 어떤 업무를 처리하고 무엇을 출력할 것인가에 대해서만 고민하면 되게 된것이다.


	웹 어플리케이션의 등장 이유
> 기존의 c/s 환경에서는 요즘의 빠른 변화의 추세에 대처할 수 없다.
> 한달에도 몇 번씩 기능이 추가되거나 변경되기 때문인데
> 그때마다 매번 클라이언트 프로그램을 재설치해야 한다면 사용자나 IT부서 담당자 모두에게 악몽일 것이다.

	웹 어플리케이션의 문제점과 개선방안
> 웹 어플리케이션도 만능은 아니다.
> 매번 출력화면을 서버에서 만들고, 클라이언트는 이 화면을 내려받아야 한다는 것이다.
> 만약 사용자가 이리저리 화면을 옮겨 다닌다면 서버는 같은 화면을 계속 반복해서 만들어야 하고, 클라이언트는 반복해서 내려받아야 한다.
> 이것은 서버 및 네트워크 자원에 대한 오버헤드를 발생시킨다.

	AJAX 
> 이를 해결하고자 AJAX라는 기술이 등장했다.
> 같은 화면에서 데이터만 바뀔 때는, 서버에서 UI전체를 받아오기보다는 데이터만 받아오는것이 효율적이기 때문인데, 이것을 가능하게 하는 기술이 AJAX이다.

	











