## 3장 언어의 기초 
- 문법 훑어보기
- 데이터 타입
- 제어문
- 함수 이해



#### 3.1.4 스트릭트 모드

ECMAScript 5에서는 '스트릭트 모드'라는 개념을 도입했다.
스트릭트 모드는 기존과는 다른 방식으로 자바스크립트를 파싱하고 실행하라고 지시하는 것인데 ECMAScript 3판의 문제를 해결했으며 
안전하지 않은 동작에는 에러를 반환하도록 합니다.
전체 스크립트에 스트릭트 모드를 적용하려면 다음 문장을 스크립트 맨 위에 추가하면 된다.

```javascript
"use strict";
```

> 이 선언은 스트릭트 모드를 지원하는 자바스크립트 엔진은 이를 인식하고 스트릭트 모드로 전환하라는 뜻으로, 
> 이 문법은 ECMAScript 3 문법과 호환되도록 만든 것이다.



#### 3.1.5 문장
ECMAScript에서 각 문장은 세미콜론으로 종료한다.
이때 세미콜론을 생략 할 수 있지만,
에러를 파악하거나 여분의 공백해서 migration 시킬때 오류등, 여러가지 문제들이 생길 여지가 있으므로 가급적 사용하자

### 3.4 데이터 타입
ECMAScript에는 다섯 가지 기본적인 데이터 타입이 있다.
이를 `원시 데이터 타입`이라고 부르는데 이 다섯가지는 다음과 같다.

- Undefined
- Null
- boolean
- 숫자
- 문자열

또한 원시 데이터 타입 외에 `객체`라는 데이터 타입도 존재한다.
ECMAScript의 데이터 타입은 동적이므로 한 가지 데이터 타입이 여러 특성을 가질 수 있다.

#### 3.4.1 typeof 연산자
ECMAScript는 느슨한 타입을 채택했으므로 변수의 데이터 타입을 알아내야 할 때가 있는데 이때 typeof 연산자를 통해 데이터 타입을 알 수 있다.

그 예는 다음과 같다

- 정의되지 않은 변수 : `undefined`
- 불리언 : `boolean`
- 문자열 : `string`
- 숫자 : `number`
- 함수를 제외한 객체 또는 null : `object`
- 함수 : `function`

#### 3.4.2 undefined 타입
`undefined`라는 값은 특별한 값이다 var를 써서 변수를 정의했지만 초기화 하지 않았다면 해당 변수에는 다음과 같이 `undefined`가 할당된다.

```javascript
var message;
alert(message == undefined);	//true
```

> 참고로 리터럴값 `undefined`는 빈 객체를 가리키는 포인터인 null과 초기화되지 않은 변수를 비교할 목적으로 ECMA-263 3판에 추가되었다.

#### 3.4.3 Null 타입
Null 타입 역시 값 하나만을 갖는다. Null타입의 값은 특별한 값인 null로, 빈 객체를 가리키는 포인터이므로 null에 typeof를 호출하면 다음 예제처럼 `object`를 반환한다.


```javascript
var car = null;
alert(typeof car);	//object
```

> 변수를 정의할 때 해당 변수가 객체를 가리키게 할 생각이라면 해당 변수에는 다른 값을 쓰지말고 null로 초기화하길 권한다.
> 그렇게 하면 해당변수가 객체를 가리키는지 명시적으로 확인할 수 있기 때문이다.

```javascript
if(car != null){
	//car를 사용하는 코드
}
```

`undefined`는 `null`에서 파생했으므로 ECMA-262에서는 두 값이 다음과 같이 표면적으로는 동일한 것으로 정의한다.

```javascript
alert(null == undefined);	//true
```

위와 같이 두값이 같다고 나오는 이유는 `==` 연산자가 피연산자를 비교할 때 암시적으로 타입 변환을 하기 때문인데, 이에 대한 내용은 뒤에서 자세히 알아보자

두 값은 서로 관련되어 있긴 하지만 아주 다르게 쓰인다.
일례로 **변수의 값에 명시적으로 undefined를 할당해서는 안되지만 null은 좀 다르다**

**==객체를 사용해야 하지만 해당 객체를 이용할 수 없을 때에는 항상 그 자리에 null이 와야 한다.==**
이렇게 하면 null이 빈 객체를 가리키는 포인터라는 점을 늘 숙지할 수 있고 undefined와 구별할 수 있게 된다.


#### 3.4.4 불리언 타입
불리언 타입은 ECMAScript에서 가장 많이 쓰이는 데이터 타입 중 하나이며, 단 두 가지 리터럴 값만 있지만 ECMAScript에서는 모든 타입을 불리언 값으로 표현할 수 있다. 각 데이터 타입별로 어떻게 형변환이 이루어지는지는 다음 표를 참고하자


| 데이터 타입 | true로 변환되는 값 | false로 변환되는 값
|--------|--------|
| 불리언 | true | false
| 문자열 | 비어 있지 않은 문자열 모두 | `""`(빈 문자열)
| 숫자 | 0이 아닌 모든 숫자, 무한대 포함 | 0, NaN
| 객체 | 모든 객체 | null
| Undefined | 해당없음 | undefined


#### 3.4.6 문자열 타입

문자열 데이터 타입은 16비트 유니코드 문자의 연속으로 큰따옴표(`""`) 나 작은따옴표(`''`)로 감싸서 표현한다.
PHP와 달리 ECMAScript에서는 둘을 구분하지 않는다.

**문자열의 성질**
ECMAScript에서 문자열은 `불변`이다.
즉 문자열이 일단 만들어지면 그 값을 바꿀 수 없다는 말이다.
변수에 저장한 문자열을 바꾸려면 기존의 문자열을 파괴하고 다음과 같이 해당 변수에 새 문자열을 채워야 한다

```javascript
var lang = "Java"
lang = lang + "Script";
```

**문자열로 변환**
값을 문자열로 바꾸는 방법은 두 가지로 
- `toString()`메소드를 사용하는 방법


그중 첫번째 방법은 ==거의 모든 값에 존재하는== `toString()` 메소드를 사용하는 방법이다.
`toString()`메소드가 하는 일은 값에 해당하는 문자열을 반환하는것 뿐이다 다음 에제를 보자

```javascript
var age = 11;
var ageAsString = age.toString();    //the string "11"
var found = true;
var foundAsString = found.toString(); //the string "true"
```

> toString()메소드는 숫자와 불리언, 객체, 문자열 값에 존재한다.(문자열에도 toString()메소드가 있는데 이를 호출하면 단순히 자신을 복사해 반환한다.)
> 단 `null`과 `undefined`에는 이 메소드가 존재하지 않는다.

또한 숫자를 호출할때 매개변수를 하나 줄수 있는데 이는 진법을 나타낸다(8진수, 16진수등...)



#### 3.4.7 객체 타입

ECMAScript에서 객체는 데이터와 기능의 집합이다.
객체는 `new` 연산자 다음에 새로 만들 객체 타입의 이름을 써서 만든다.
다음과 같이 `Object`타입의 `인스턴스`를 만들고 프로퍼티나 메소드를 추가하여 객체를 만들 수 있다

```javascript
var o = new Object();
```

이 문법은 자바와 비슷하긴 하지만 ECMAScript에서는 생성자에 매개변수를 넘기지 않는다면 괄호를 생략해도 된다.
매개변수가 없다면 다음 예제 처럼 괄호를 생략해도 안전하긴 하지만 권장하지는 않는다.

```javascript
var o = new Object;	//유효하지만 권장하지 않음
```

> ECMAScript의 `Object` 타입은 자바의 `java.lang.Object`처럼 이 타입에서 파생하는 모든 객체의 원형이다.
> Object 타입의 인스턴스는 Object 타입의 프로퍼티와 메소드를 전부 상속한다.

Obejct 의 인스턴스는 다음 프로퍼티와 메소드를 가진다.

- constructor : 해당 객체를 만드는 데 쓰인함수. 위 예제로 치면 `Object()`함수가 생성자다
- hasOwnProperty(propertyName) : 해당 프로퍼티가 객체 인스턴스에 고유하며 프로토타입에서 상속하지 않았음을 확인하며, 프로퍼티 이름은 반드시 문자열이어야 한다. 예를 들어 o.hasOwnProperty("name")같은 형식으로 호출한다.
- isPrototypeOf(object) : 해당 객체가 다른 객체의 프로토타입인지 확인한다.
- propertyIsEnumerable(propertyName) : 해당 프로퍼티를 `for-in` 문에서 나열할 수 있는지 확인한다. 위 메소드와 마찬가지로 프로퍼티 이름에는 반드시 문자열을 써야 한다.
- toLocaleString() : 객체를 지역에 맞게 표현한 문자열을 반환한다.
- toString() : 객체를 문자열로 변환해 반환한다.
- valueOf() : 객체를 나타내는 문자열이나 숫자, 불리언을 반환한다 

> ECMAScript에서는 모든 객체가 `Object`에 기반해 만들어지므로 이들 프로퍼티와 메소드는 모든 객체에 존재한다. 


### 3.7 함수

함수는 문장을 캡슐화하여 어디서든, 언제든 실행할 수 있게 하므로 모든 언어의 핵심이다.

ECMAScript 의 함수는 꼭 값을 반환하지 않아도 된다.

스트릭트 모드에서는 함수에 다음과 같은 제한이 있다.
- 함수 이름에 `eval`이나 `arguments`는 사용할 수 없다.
- 매개변수 이름에도 `eval`이나 `arguments`를 쓸 수 없다.
- 서로 다른 매개벼니수에 결고 같은 이름을 쓸 수 없다.

#### 3.7.1 매개변수의 이해

ECMAScript의 함수의 매개변수는 다른 언어와 다르게 동작한다.
- 매개변수 숫자를 따지지 않는다.
- 데이터 타입도 체크하지 않는다.

가령 함수에서 매개변수를 두 개 받도록 만들었더라도, 매개변수를 한개, 세개, 또는 아예 넘기지 않더라도 인터프리터는 이를 에러로 간주 하지 않는데, 

> 이는 ECMAScript의 매개변수가 내부적으로는 배열로 표현되기 때문이다.
> 이 배열은 항상 함수에 전달되지만 함수는 배열에 어떤 값이 들어 있는지 체크하지 않습니다. 빈 배열이 들어와도 상관없고, 필요한 매개변수보다 많이 들어와도 괜찮다.

> 함수는 `arguments`라는 객체를 하나 갖는데, 이 객체를 통해 매개변수의 값에 접근할 수 있다.

`arguments` 객체는 각 매개변수를 대괄호 표기법, 즉 첫번째 매개변수는 arguments[0]와 같은 형태로 접근하며, 매개변수를 `length` 프로퍼티를 통해 알 수 있다는 면에서 배열처럼 동작하기는 하지만 `Array`의 인스턴스는 아니다.

가령 아래와 같이 함수에 명시적으로 매개변수를 표현하지 않고도 사용가능하다. 매개변수로 넘김 값을 사용가능하다.

```javascript
function sayHi(){
	alert("Hello" + arguments[0]);
}
```

> 위 예제는 ECMAScript 함수의 중요한 특징을 묘사하는데 
> 이름 붙은 매개변수는 편리하긴 하지만 반드시 필요한건 아니고, 다른언어와 달리 매개변수에 이름을 붙인다 해서 함수 시그니처를 만들고 나중에 검사하지 않는다.
> 다시 말해 이름 붙은 매개변수의 유효성 검사를 하지 않는다는 뜻이다.

`arguments` 객체의 `length`프로퍼티를 통해 함수에 매개변수가 몇 개 전될되었는지 알 수 잇다.

다음 예제를 통해 살펴보자

```javascript
function howManyArgs(){
	alert(arguments.length);
}

howManyArgs("string", 45);	//2
howManyArgs();				//0
howManyArgs(12);			  //1
```

이런 방법을 통해 함수가 받는 매개변수 숫자에 제한을 두지 않고 넘겨받은 매개변수 개수에 맞게 반응할 수 있다.

```javascript
function doAdd(){
	if(arguments.length == 1){
   	alert(arguments[0] + 10);
   } else if(arguments.length == 2){
   	alert(arguments[0] + arguments[1]);
   }
}

doAdd(10);		//20
doAdd(30,20);	 //50
```

위 예제와 같은 방식은 오버로딩만큼 좋지는 않지만 ECMAScript의 제한을 경감하기에 충분하다.

**매개변수에서 또 다른 중요한 점은 다음과 같이 `arguments`객체를 이름 붙은 매개변수와 함께 쓸 수 있다는 것이다.**

```javascript
function doAdd(num1, num2){
	if(arguments.length == 1){
   	alert(num1 + 10);
   } else if(arguments.length == 2){
   	alert(arguments[0] + num2);
   }
}
```

`arguments` 객체에서 한 가지 더 재미있는 점은 이 객체의 프로퍼티 값을 이에 대응하는 이름 붙은 매개변수에서 자동으로 반영한다는 점이다. 
예를 들면 다음과 같다.

```javascript
function doAdd(num1, num2){
	arguments[1] = 10;
	alert(arguments[0] + num2);
}
```

위의 함수는 항상 두번째 매개변수의 값을 10으로 바꾼다.
즉 `arguments[1]`의 값을 바꾸면 num2도 바뀌며 결국 둘 모두 10이 된다.

> 여기서 이 둘이 같은 메모리 공간을 쓰는 건 아니다. 둘은 각각 다른 메모리 공간을 사용하지만 값은 반영된다.
> 그런데 이는 동기화가 아니라 단방향 반영이다.
> 즉 이름 붙은 매개변수의 값을 바꾸더라도 arguments의  해당 프로퍼티는 바뀌지 **않는다** 

또 하나 기억해야 할 것은 매개변수를 하나만 넘기면 arguments[1]의 값을 바꾸더라도 이름붙은 매개변수에는 아무 영향도 없다는 것이다.
이렇게 되는 이유는 arguments 객체의 length 프로퍼티가 함수 정의에서 정의한 매개변수 숫자를 따르지 않고 함수를 호출할 때 넘긴 이름 붙은 매개변수 목록을 따르기 때문이다.

함수를 정의할 때 함께 정의한 매개변수를 넘기지 않으면 해당 매개변수에는 자동으로 `undefined`가 할당된다.
이는 변수를 정의하기만 하고 초기화하지는 않은 것과 비슷하다.

> 스트릭트 모드는 arguments 객체의 동작방식을 여러가지로 바꿨다.

먼저 바로 이전 예제에서 보인 할당 방식은 동작하지 않는다.
즉 arguments[1]의 값을 10으로 바꾸더라도 num2는 계속 undefined 상태로 남는다.


#### 3.7.2 오버로딩 없음

ECMAScript 함수에는 다른 언어에서 사용하는 오버로딩이 없다.
예를 들어 자바에서는 함수 이름ㅁ이 같더라도 시그니처(매개변수의 타입과 개수)만 다르면 서로 다르게 동작하도록 정의할 수 있다.

이미 언급했듯 ECMAScript 함수에는 시그니처가 없는데 매개변수는 그저 배열일 뿐이며 그 값에 제한이 없기 때문이다.




